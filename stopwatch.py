import time

#Класс таймер
class Stopwatch:
    #Инициализация. Принимаем количество проходов или дефолт
    def __init__(self, num_runs=1):
        self.num_runs = num_runs
    #Принимаем на вход некоторую функцию, скорость работы которой нужно подсчитать
    def __call__(self, func):
        #Принимаем аргументы декорируемой функции, сколько угодно много
        def wrapped_f(*args):
            #инициализируем переменную
            self.avg_time = 0
            #делаем n-количество проходов считая общее время выполнения
            for _ in range(self.num_runs):
                t0 = time.time()
                func(*args)
                t1 = time.time()
                self.avg_time += (t1 - t0)
            #вычисляем среднее время выполнения
            self.avg_time /= self.num_runs
            print("Выполнение заняло %.5f секунд" % self.avg_time)
        return wrapped_f
    #Используется для работы контекстного менеджера
    def __enter__(self):
        print('Контекстный менеджер вызвал __enter__')
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        #для всплытия исключения выше
        print('Контекстный менеджер вызвал __exit__')
        if exc_value: raise
        return True


#функция с декоратором @Stopwatch. Можно задать любое количество проходов или не задавать вообще - @Stopwatch(), тогда проход будет один
@Stopwatch(num_runs=10)
#исполняемая функция, быстродействие которой необходимо посчитать. Можно использовать и другую функцию, например подсчет числа пи
def f(numInRange=1000000):
    for _ in range(numInRange):
        pass
#вызов исполняемой функции. Можно задать количество повторений цикла, например f(1000000). Если не задавать, берет по умолчанию
f()
#контекстный менеджер. делает то же самое, но для проверки работоспособности нужно закомментить декоратор функции f. т.е. строку "@Stopwatch(num_runs=10)", иначе получим функцию, декорированную дважды
# with Stopwatch(num_runs=10) as h:
#     h(f)(1000000)
